---
title: "Final Project"
author: "Saujanya Acharya and Rona Hu"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE}
library(dplyr)
library(rvest)
library(httr)
library(httr)
library(memoise)
library(jsonlite)
library(cachem)
library(RSelenium)
library(leaflet)
library(geosphere)
```


## Step 1 : Acquiring Qs University Ranking from 2024 data
```{r}

tryCatch({
  driver$server$stop()
  print("Running Selenium driver was stopped, a new session will now be started")
}, error = function(e){
  print("New Selenium driver to be started")
})

# Start a Selenium server
driver <- rsDriver(browser = "firefox")
remote_driver <- driver[["client"]]


# Function to scrape university names
scrape_university_names <- (function() {
  webpage <- read_html(remote_driver$getPageSource()[[1]])
  print(html_nodes(webpage, ".uni-link"))
  universities <- webpage %>%
    html_nodes(".uni-link") %>%
    html_text()
  return(universities)
})


# Navigate to the URL
url <- "https://www.topuniversities.com/world-university-rankings?region=North%20America&countries=us"

remote_driver$open()
remote_driver$navigate(url)

Sys.sleep(15)
# Scrape data and navigate to the next page iteratively
all_universities <- character(0)
load_more_exists <- TRUE

while (load_more_exists) {
  # Get university names
  all_universities <- c(scrape_university_names())
  
 
  # Click on the next page button if it exists
  tryCatch({
    hidden_button <- remote_driver$findElement(using="xpath", "//div[@pageno='13']")
    load_more_exists <- FALSE
    
  }, error = function(e) {
    load_more_button <- remote_driver$findElement(using="class name", value="loadmorebutton")
    load_more_button$clickElement()
    load_more_exists <- TRUE
  })

  Sys.sleep(15)
}
  
# 

# Stop the Selenium server
remote_driver$close()
driver$server$stop()


# Print the extracted university names
university_data <- data.frame(Name = all_universities)

```

## Step 2 : Getting geocodes from google maps api
``` {r}
library(googleway)

cache_file <- cachem::cache_disk("./cache/.uni_map_cachefile")

source(".api-key.R")
api_key <- api$google_api_key
# Set your Google Maps API key

# Function to get coordinates for a university by name
get_university_coordinates <- memoise(function(university_name) {
  result <- google_geocode(address = university_name, key = api_key)

  # Check if the result contains any data
  if (length(result$results) > 0) {
    location <- c(result$results$geometry$location$lat, result$results$geometry$location$lng)
    return(location)
  } else {
    return(c(NA, NA))
  }
}, cache = cache_file)

# Apply the function to each university name in the data frame
university_data$Coordinates <- lapply(university_data$Name, get_university_coordinates)

```

## Step 5 : Cleaning Google Maps Coordinate data
```{r}

#Takes the first result from Google Maps
university_data$Coordinates <- lapply(university_data$Coordinates, function(x) {
  if (!any(is.na(x)) & length(x) > 2) {
    return(c(x[1], x[3]))
  } else {
    return(x)
  }
})

```

## Step 6 : Showing universities in a map
```{r}

# Assuming university_data is your data frame
university_data$Latitude <- sapply(university_data$Coordinates, function(coord) coord[1])
university_data$Longitude <- sapply(university_data$Coordinates, function(coord) coord[2])

# Convert the new columns to numeric (if needed)
university_data$Latitude <- as.numeric(university_data$Latitude)
university_data$Longitude <- as.numeric(university_data$Longitude)

# Create a data frame for leaflet
map <- leaflet(university_data) %>%
  addTiles() %>%
  addMarkers(
    lat = ~Latitude,
    lng = ~Longitude,
    popup = ~as.character(Name)  # Assuming you have a column named "Name" for university names
  )

# Print the map
print(map)
```
## Clustering universities based on their latitudes and longitudes
```{r}
# Extract coordinates from the "Coordinates" column
coordinates <- matrix(unlist(university_data$Coordinates), ncol = 2, byrow = TRUE)

wss <- numeric(10)

# Iterate over different values of k
for (i in 1:10) {
  # Perform k-means clustering
  clusters <- kmeans(coordinates, centers = i)
  
  # Store the within-cluster sum of squares in the vector
  wss[i] <- clusters$tot.withinss
}

# Plot the elbow curve
plot(1:10, wss, type = "b", xlab = "Number of Clusters", ylab = "Within Sum of Squares")

# Perform k-means clustering with, for example, k=5 (you can adjust this value)
k <- 5
clusters <- kmeans(coordinates, centers = k)

# Add the cluster assignment to your data frame
university_data$Cluster <- clusters$cluster

# Display the result
print(university_data)
```
## Showing the above cluster in map
```{r}
map <- leaflet(university_data) %>%
  addTiles()  # You can customize the map tiles if needed

cluster_colors <- c("red", "blue", "green", "orange", "purple")

# Add circle markers for each university with color based on cluster
map <- map %>%
  addCircleMarkers(
    lng = ~Longitude,
    lat = ~Latitude,
    color = ~cluster_colors[Cluster],
    popup = ~as.character(Name),
    label = ~as.character(Cluster),
    radius = 6
  ) %>%
  addLegend("bottomright", title = "Clusters", colors = 1:k, labels = 1:k)

# Print the map
map
```


